<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electric Load Forecasting</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/plotly.js-dist"></script>
    <style>
        :root {
          --primary-color: #6d28d9;
          --primary-light: #8b5cf6;
          --primary-dark: #5b21b6;
          --secondary-color: #10b981;
          --secondary-light: #34d399;
          --secondary-dark: #059669;
          --accent-color: #f59e0b;
          --accent-light: #fbbf24;
          --accent-dark: #d97706;
          --background-color: #111827;
          --card-bg: #1f2937;
          --text-color: #f3f4f6;
          --text-muted: #9ca3af;
          --border-color: #374151;
          --success-color: #10b981;
          --error-color: #ef4444;
          --warning-color: #f59e0b;
          --info-color: #3b82f6;
        }
        
        body {
          font-family: "Poppins", sans-serif;
          background-color: var(--background-color);
          color: var(--text-color);
          margin: 0;
          padding: 0;
          min-height: 100vh;
          overflow-x: hidden;
        }
        
        /* Animated background */
        .animated-background {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: -1;
          overflow: hidden;
        }
        
        .animated-background::before {
          content: "";
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: radial-gradient(circle at 50% 50%, rgba(109, 40, 217, 0.15), transparent 60%);
          animation: pulse 15s infinite alternate;
        }
        
        .animated-background::after {
          content: "";
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: radial-gradient(circle at 80% 20%, rgba(16, 185, 129, 0.1), transparent 50%);
          animation: pulse 20s infinite alternate-reverse;
        }
        
        @keyframes pulse {
          0% {
            transform: scale(1);
            opacity: 0.5;
          }
          50% {
            transform: scale(1.5);
            opacity: 0.8;
          }
          100% {
            transform: scale(1);
            opacity: 0.5;
          }
        }
        
        .particles {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
        }
        
        .particle {
          position: absolute;
          background: rgba(255, 255, 255, 0.1);
          border-radius: 50%;
          pointer-events: none;
        }
        
        .container {
          max-width: 1200px;
          margin: 0 auto;
          padding: 2rem 1rem;
          position: relative;
          z-index: 1;
        }
        
        .app-header {
          background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
          color: white;
          padding: 2.5rem;
          border-radius: 1rem;
          margin-bottom: 2rem;
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
          position: relative;
          overflow: hidden;
          transition: all 0.3s ease;
        }
        
        .app-header::before {
          content: "";
          position: absolute;
          top: -50%;
          left: -50%;
          width: 200%;
          height: 200%;
          background: radial-gradient(circle at center, rgba(255, 255, 255, 0.1) 0%, transparent 60%);
          transform: rotate(30deg);
          animation: shimmer 10s infinite linear;
        }
        
        @keyframes shimmer {
          0% {
            transform: rotate(0deg);
          }
          100% {
            transform: rotate(360deg);
          }
        }
        
        .app-title {
          font-weight: 800;
          margin: 0;
          font-size: 3rem;
          text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
          background: linear-gradient(to right, #fff, #d8b4fe);
          -webkit-background-clip: text;
          -webkit-text-fill-color: transparent;
          position: relative;
          z-index: 1;
        }
        
        .app-subtitle {
          opacity: 0.9;
          margin-top: 0.5rem;
          font-size: 1.2rem;
          position: relative;
          z-index: 1;
        }
        
        .nav-tabs {
          display: flex;
          border-bottom: 1px solid var(--border-color);
          margin-bottom: 0;
          background-color: var(--card-bg);
          border-radius: 0.75rem 0.75rem 0 0;
          overflow: hidden;
        }
        
        .nav-tabs .nav-link {
          border: none;
          color: var(--text-muted);
          font-weight: 600;
          padding: 1rem 1.5rem;
          transition: all 0.3s ease;
          position: relative;
          background: transparent;
          cursor: pointer;
        }
        
        .nav-tabs .nav-link:hover {
          color: var(--text-color);
        }
        
        .nav-tabs .nav-link.active {
          color: var(--primary-light);
          background-color: transparent;
        }
        
        .nav-tabs .nav-link.active::after {
          content: "";
          position: absolute;
          bottom: 0;
          left: 0;
          width: 100%;
          height: 3px;
          background: linear-gradient(to right, var(--primary-color), var(--primary-light));
          border-radius: 3px 3px 0 0;
        }
        
        .tab-content {
          padding: 1.5rem;
          border: 1px solid var(--border-color);
          border-top: none;
          border-radius: 0 0 0.75rem 0.75rem;
          background-color: var(--card-bg);
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .card {
          background-color: var(--card-bg);
          border: 1px solid var(--border-color);
          border-radius: 0.75rem;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          margin-bottom: 1.5rem;
          overflow: hidden;
          transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
          transform: translateY(-5px);
          box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }
        
        .card-header {
          background-color: rgba(0, 0, 0, 0.2);
          border-bottom: 1px solid var(--border-color);
          font-weight: 700;
          padding: 1rem 1.5rem;
          color: var(--text-color);
        }
        
        .card-body {
          padding: 1.5rem;
        }
        
        .form-label {
          font-weight: 600;
          margin-bottom: 0.5rem;
          color: var(--text-color);
        }
        
        .form-control,
        .form-select {
          background-color: var(--background-color);
          border: 1px solid var(--border-color);
          border-radius: 0.5rem;
          color: var(--text-color);
          padding: 0.75rem 1rem;
          transition: all 0.3s ease;
        }
        
        .form-control:focus,
        .form-select:focus {
          border-color: var(--primary-light);
          box-shadow: 0 0 0 0.25rem rgba(139, 92, 246, 0.25);
          background-color: rgba(0, 0, 0, 0.2);
        }
        
        .form-range {
          height: 1.5rem;
          padding: 0;
        }
        
        .form-range::-webkit-slider-thumb {
          background: var(--primary-color);
        }
        
        .form-range::-moz-range-thumb {
          background: var(--primary-color);
        }
        
        .help-text {
          margin-top: 0.5rem;
          font-size: 0.875rem;
          color: var(--text-muted);
        }
        
        .btn {
          font-weight: 600;
          padding: 0.75rem 1.5rem;
          border-radius: 0.5rem;
          transition: all 0.3s ease;
        }
        
        .btn-primary {
          background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
          border: none;
          color: white;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .btn-primary:hover {
          background: linear-gradient(135deg, var(--primary-light), var(--primary-color));
          transform: translateY(-2px);
          box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        
        .btn-primary:active {
          transform: translateY(0);
        }
        
        .btn-group .btn {
          border-radius: 0;
          background-color: rgba(0, 0, 0, 0.2);
          border: 1px solid var(--border-color);
          color: var(--text-muted);
        }
        
        .btn-group .btn:first-child {
          border-top-left-radius: 0.5rem;
          border-bottom-left-radius: 0.5rem;
        }
        
        .btn-group .btn:last-child {
          border-top-right-radius: 0.5rem;
          border-bottom-right-radius: 0.5rem;
        }
        
        .btn-group .btn.active {
          background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
          border-color: var(--primary-color);
          color: white;
        }
        
        .loading {
          display: none;
          text-align: center;
          margin: 2rem 0;
        }
        
        .spinner-border {
          width: 3rem;
          height: 3rem;
          border-width: 0.25rem;
          color: var(--primary-light);
        }
        
        .chart-container {
          width: 100%;
          height: 450px;
          margin-top: 1.5rem;
          border-radius: 0.75rem;
          overflow: hidden;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          background-color: rgba(0, 0, 0, 0.2);
          border: 1px solid var(--border-color);
        }
        
        .time-selector {
          display: flex;
          justify-content: center;
          margin: 1rem 0;
          overflow-x: auto;
          padding-bottom: 0.5rem;
        }
        
        .time-selector .time-btn {
          padding: 0.5rem 1rem;
          margin: 0 0.25rem;
          border: 1px solid var(--border-color);
          border-radius: 0.5rem;
          background-color: rgba(0, 0, 0, 0.2);
          color: var(--text-muted);
          cursor: pointer;
          transition: all 0.3s ease;
          font-size: 0.875rem;
          font-weight: 500;
        }
        
        .time-selector .time-btn:hover {
          background-color: rgba(0, 0, 0, 0.3);
          color: var(--text-color);
        }
        
        .time-selector .time-btn.active {
          background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
          border-color: var(--primary-color);
          color: white;
        }
        
        .point-info {
          margin-top: 1.5rem;
          padding: 1.5rem;
          background-color: rgba(59, 130, 246, 0.1);
          border: 1px solid rgba(59, 130, 246, 0.2);
          border-radius: 0.75rem;
          display: none;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .point-info h5 {
          margin-top: 0;
          color: var(--info-color);
          font-weight: 700;
          margin-bottom: 1rem;
        }
        
        .metrics-container {
          margin-top: 1.5rem;
          padding: 1.5rem;
          background-color: rgba(16, 185, 129, 0.1);
          border: 1px solid rgba(16, 185, 129, 0.2);
          border-radius: 0.75rem;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .metrics-container h4 {
          color: var(--secondary-color);
          font-weight: 700;
          margin-top: 0;
          margin-bottom: 1rem;
        }
        
        .metrics-table {
          width: 100%;
          margin-bottom: 0;
        }
        
        .metrics-table td {
          padding: 0.75rem 1rem;
          border-bottom: 1px solid rgba(16, 185, 129, 0.1);
        }
        
        .metrics-table td:first-child {
          font-weight: 600;
          width: 60%;
        }
        
        .summary-card {
          background-color: rgba(245, 158, 11, 0.1);
          border: 1px solid rgba(245, 158, 11, 0.2);
          border-radius: 0.75rem;
          padding: 1.5rem;
          margin-top: 1.5rem;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .summary-card h4 {
          margin-top: 0;
          color: var(--accent-color);
          font-weight: 700;
          margin-bottom: 1rem;
        }
        
        .summary-stats {
          display: flex;
          flex-wrap: wrap;
          gap: 1rem;
          margin-top: 1rem;
        }
        
        .stat-item {
          flex: 1;
          min-width: 150px;
          background-color: rgba(0, 0, 0, 0.2);
          padding: 1.25rem;
          border-radius: 0.75rem;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          border: 1px solid var(--border-color);
          transition: transform 0.3s ease;
        }
        
        .stat-item:hover {
          transform: translateY(-5px);
        }
        
        .stat-label {
          font-size: 0.875rem;
          color: var(--text-muted);
          margin-bottom: 0.5rem;
        }
        
        .stat-value {
          font-size: 1.5rem;
          font-weight: 700;
          color: var(--accent-color);
          text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .table {
          color: var(--text-color);
          background-color: transparent;
        }
        
        .table th {
          font-weight: 600;
          color: var(--text-color);
          border-bottom: 2px solid var(--border-color);
          padding: 0.75rem 1rem;
        }
        
        .table td {
          padding: 0.75rem 1rem;
          border-bottom: 1px solid var(--border-color);
        }
        
        .table-striped tbody tr:nth-of-type(odd) {
          background-color: rgba(0, 0, 0, 0.1);
        }
        
        .table-hover tbody tr:hover {
          background-color: rgba(0, 0, 0, 0.2);
        }
        
        .accordion-item {
          background-color: var(--card-bg);
          border: 1px solid var(--border-color);
          margin-bottom: 0.5rem;
          border-radius: 0.5rem;
          overflow: hidden;
        }
        
        .accordion-header {
          margin: 0;
        }
        
        .accordion-button {
          background-color: rgba(0, 0, 0, 0.2);
          color: var(--text-color);
          font-weight: 600;
          padding: 1rem 1.5rem;
          width: 100%;
          text-align: left;
          border: none;
          transition: all 0.3s ease;
        }
        
        .accordion-button:not(.collapsed) {
          background-color: rgba(109, 40, 217, 0.1);
          color: var(--primary-light);
        }
        
        .accordion-button:focus {
          box-shadow: none;
          border-color: var(--primary-color);
        }
        
        .accordion-button::after {
          background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23f3f4f6'%3e%3cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3e%3c/svg%3e");
        }
        
        .accordion-body {
          padding: 1.5rem;
          background-color: rgba(0, 0, 0, 0.1);
        }
        
        /* Tooltip */
        #tooltip {
          position: absolute;
          display: none;
          background: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 0.75rem 1rem;
          border-radius: 0.5rem;
          font-size: 0.875rem;
          pointer-events: none;
          z-index: 1000;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          max-width: 300px;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
          .app-header {
            padding: 1.5rem;
          }
        
          .app-title {
            font-size: 2rem;
          }
        
          .chart-container {
            height: 350px;
          }
        
          .stat-item {
            min-width: 120px;
          }
        
          .nav-tabs .nav-link {
            padding: 0.75rem 1rem;
            font-size: 0.875rem;
          }
        }
        
        /* Animations */
        @keyframes fadeIn {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
        
        .fade-in {
          animation: fadeIn 0.5s ease forwards;
        }
        
        /* Glowing effect for buttons */
        .btn-glow {
          position: relative;
          overflow: hidden;
        }
        
        .btn-glow::after {
          content: "";
          position: absolute;
          top: -50%;
          left: -50%;
          width: 200%;
          height: 200%;
          background: radial-gradient(circle at center, rgba(255, 255, 255, 0.2) 0%, transparent 60%);
          transform: rotate(30deg);
          animation: shimmer 10s infinite linear;
          pointer-events: none;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
          width: 10px;
          height: 10px;
        }
        
        ::-webkit-scrollbar-track {
          background: var(--background-color);
        }
        
        ::-webkit-scrollbar-thumb {
          background: var(--primary-dark);
          border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
          background: var(--primary-color);
        }

        #help .card-body,
#help .accordion-body {
    color: #ffffff !important;
}

    </style>
</head>
<body>
    <!-- Animated Background -->
    <div class="animated-background">
        <canvas id="particles-canvas" class="particles"></canvas>
    </div>
    
    <div class="container">
        <div class="app-header text-center">
            <h1 class="app-title">Electric Load Forecasting</h1>
            <p class="app-subtitle">Predict and analyze energy demand patterns with advanced machine learning models</p>
        </div>
        
        <ul class="nav nav-tabs" id="myTab" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="forecast-tab" data-bs-toggle="tab" data-bs-target="#forecast" type="button" role="tab" aria-controls="forecast" aria-selected="true">
                    <i class="fas fa-chart-line"></i> Forecasting
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="cluster-tab" data-bs-toggle="tab" data-bs-target="#cluster" type="button" role="tab" aria-controls="cluster" aria-selected="false">
                    <i class="fas fa-object-group"></i> Clustering
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="help-tab" data-bs-toggle="tab" data-bs-target="#help" type="button" role="tab" aria-controls="help" aria-selected="false">
                    <i class="fas fa-question-circle"></i> Help & Documentation
                </button>
            </li>
        </ul>
        
        <div class="tab-content" id="myTabContent">
            <!-- Forecasting Tab -->
            <div class="tab-pane fade show active" id="forecast" role="tabpanel" aria-labelledby="forecast-tab">
                <div class="row">
                    <div class="col-md-4">
                        <div class="card">
                            <div class="card-header">Forecast Settings</div>
                            <div class="card-body">
                                <form id="forecast-form">
                                    <div class="mb-3">
                                        <label for="city" class="form-label">City</label>
                                        <select class="form-select" id="city" name="city" required>
                                            <option value="" selected disabled>Select a city</option>
                                            {% for city in cities %}
                                            <option value="{{ city }}">{{ city|capitalize }}</option>
                                            {% endfor %}
                                        </select>
                                        <div class="help-text">Select the city for which you want to forecast electric load.</div>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <label for="start_date" class="form-label">Start Date</label>
                                        <input type="text" class="form-control date-picker" id="start_date" name="start_date" required>
                                        <div class="help-text">Select the start date for your forecast period.</div>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <label for="end_date" class="form-label">End Date</label>
                                        <input type="text" class="form-control date-picker" id="end_date" name="end_date" required>
                                        <div class="help-text">Select the end date for your forecast period (max 30 days from start).</div>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <label for="forecast_interval" class="form-label">Forecast Interval</label>
                                        <select class="form-select" id="forecast_interval" name="forecast_interval">
                                            <option value="hourly" selected>Hourly</option>
                                            <option value="two_hourly">Every 2 Hours</option>
                                            <option value="daily">Daily</option>
                                        </select>
                                        <div class="help-text">Choose the time interval for your forecast.</div>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <label for="model_type" class="form-label">Model Type</label>
                                        <select class="form-select" id="model_type" name="model_type">
                                            <option value="arima" selected>ARIMA</option>
                                            <option value="linear_reg">Linear Regression</option>
                                            <option value="random_forest">Random Forest</option>
                                            <option value="xgboost">XGBoost</option>
                                            <option value="lstm">LSTM</option>
                                        </select>
                                        <div class="help-text">Select the forecasting model to use. Different models may perform better for different cities and time periods.</div>
                                    </div>
                                    
                                    <button type="submit" class="btn btn-primary w-100">
                                        <i class="fas fa-chart-line"></i> Generate Forecast
                                    </button>
                                </form>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-8">
                        <div id="forecast-loading" class="loading">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p>Generating forecast...</p>
                        </div>
                        
                        <div id="forecast-result" class="result-container" style="display: none;">
                            <div class="card">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <h3 class="m-0">Forecast Results</h3>
                                    <div class="forecast-options">
                                        <div class="btn-group" role="group" aria-label="View options">
                                            <button type="button" class="btn active" id="view-all">All</button>
                                            <button type="button" class="btn" id="view-predicted">Predicted</button>
                                            <button type="button" class="btn" id="view-actual">Actual</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <div id="time-selector" class="time-selector" style="display: none;"></div>
                                    <div id="forecast-plot" class="chart-container"></div>
                                    
                                    <div id="point-info" class="point-info">
                                        <h5>Point Details</h5>
                                        <div id="point-details"></div>
                                    </div>
                                    
                                    <div id="metrics-container" class="metrics-container" style="display: none;">
                                        <h4>Model Performance Metrics</h4>
                                        <table class="metrics-table">
                                            <tr>
                                                <td>Mean Absolute Error (MAE):</td>
                                                <td id="mae-value">-</td>
                                            </tr>
                                            <tr>
                                                <td>Root Mean Square Error (RMSE):</td>
                                                <td id="rmse-value">-</td>
                                            </tr>
                                            <tr>
                                                <td>Mean Absolute Percentage Error (MAPE):</td>
                                                <td id="mape-value">-</td>
                                            </tr>
                                        </table>
                                    </div>
                                    
                                    <div class="summary-card">
                                        <h4>Forecast Summary</h4>
                                        <div class="summary-stats" id="forecast-summary-stats"></div>
                                        <p id="forecast-summary" class="mt-3"></p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Clustering Tab -->
            <div class="tab-pane fade" id="cluster" role="tabpanel" aria-labelledby="cluster-tab">
                <div class="row">
                    <div class="col-md-4">
                        <div class="card">
                            <div class="card-header">Clustering Settings</div>
                            <div class="card-body">
                                <form id="cluster-form">
                                    <div class="mb-3">
                                        <label for="k_value" class="form-label">Number of Clusters (k)</label>
                                        <input type="range" class="form-range" id="k_value" name="k_value" min="2" max="10" value="3">
                                        <div class="d-flex justify-content-between">
                                            <span>2</span>
                                            <span id="k_value_display">3</span>
                                            <span>10</span>
                                        </div>
                                        <div class="help-text">Adjust the number of clusters to identify different patterns in the data.</div>
                                    </div>
                                    
                                    <button type="submit" class="btn btn-primary w-100">
                                        <i class="fas fa-object-group"></i> Generate Clusters
                                    </button>
                                </form>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-8">
                        <div id="cluster-loading" class="loading">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p>Generating clusters...</p>
                        </div>
                        
                        <div id="cluster-result" class="result-container" style="display: none;">
                            <div class="card">
                                <div class="card-header">
                                    <h3 class="m-0">Clustering Results</h3>
                                </div>
                                <div class="card-body">
                                    <div id="cluster-plot" class="chart-container"></div>
                                    
                                    <div class="cluster-stats mt-4">
                                        <h4>Cluster Statistics</h4>
                                        <div id="cluster-stats-container"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Help & Documentation Tab -->
            <div class="tab-pane fade" id="help" role="tabpanel" aria-labelledby="help-tab">
                <div class="card">
                    <div class="card-header">
                        <h3 class="m-0">Help & Documentation</h3>
                    </div>
                    <div class="card-body">
                        <div class="accordion" id="helpAccordion">
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingOne">
                                    <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                                        Using the Forecasting Tool
                                    </button>
                                </h2>
                                <div id="collapseOne" class="accordion-collapse collapse show" aria-labelledby="headingOne" data-bs-parent="#helpAccordion">
                                    <div class="accordion-body">
                                        <p>The forecasting tool allows you to predict electric load for different cities over a specified time period.</p>
                                        <ol>
                                            <li><strong>Select a City:</strong> Choose the city for which you want to forecast electric load.</li>
                                            <li><strong>Choose Date Range:</strong> Select the start and end dates for your forecast period. For best results, keep the forecast period under 30 days.</li>
                                            <li><strong>Select Forecast Interval:</strong> Choose between hourly, every 2 hours, or daily forecasts.</li>
                                            <li><strong>Select Model Type:</strong> Choose from different forecasting models:
                                                <ul>
                                                    <li><strong>ARIMA:</strong> Autoregressive Integrated Moving Average - good for short-term forecasts.</li>
                                                    <li><strong>Linear Regression:</strong> Simple and interpretable model for linear relationships.</li>
                                                    <li><strong>Random Forest:</strong> Ensemble learning method that can capture non-linear relationships.</li>
                                                    <li><strong>XGBoost:</strong> Gradient boosting algorithm that often provides high accuracy.</li>
                                                    <li><strong>LSTM:</strong> Long Short-Term Memory neural network - excellent for time series with long-term dependencies.</li>
                                                </ul>
                                            </li>
                                            <li><strong>Generate Forecast:</strong> Click the button to generate the forecast.</li>
                                        </ol>
                                        <p>The forecast will be displayed as an interactive chart showing predicted load values over time. If actual data is available for the selected period, it will also be shown for comparison. Hover over any point to see the exact values, and click on a point to see detailed information.</p>
                                        <p>Below the chart, you'll see performance metrics (if actual data is available) and a summary of the forecast.</p>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingTwo">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                                        Using the Clustering Tool
                                    </button>
                                </h2>
                                <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo" data-bs-parent="#helpAccordion">
                                    <div class="accordion-body">
                                        <p>The clustering tool helps identify patterns in the electric load data by grouping similar data points together.</p>
                                        <ol>
                                            <li><strong>Adjust Number of Clusters (k):</strong> Use the slider to set the number of clusters. More clusters will create more specific groupings, while fewer clusters will create broader categories.</li>
                                            <li><strong>Generate Clusters:</strong> Click the button to perform the clustering analysis.</li>
                                        </ol>
                                        <p>The results will be displayed as an interactive scatter plot where each point represents a data point and colors indicate different clusters. The plot uses Principal Component Analysis (PCA) to reduce the dimensionality of the data for visualization. Hover over any point to see its feature values.</p>
                                        <p>Below the plot, you'll see statistics for each cluster, including the average temperature, humidity, wind speed, and percentage of weekend days in each cluster.</p>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingThree">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                                        Technical Details
                                    </button>
                                </h2>
                                <div id="collapseThree" class="accordion-collapse collapse" aria-labelledby="headingThree" data-bs-parent="#helpAccordion">
                                    <div class="accordion-body">
                                        <h5>Data Sources</h5>
                                        <p>The application uses historical electric load data combined with weather data for multiple cities. The data includes:</p>
                                        <ul>
                                            <li>Electric load (MW)</li>
                                            <li>Temperature (°F)</li>
                                            <li>Humidity (%)</li>
                                            <li>Wind speed (mph)</li>
                                            <li>Day of week</li>
                                            <li>Hour of day</li>
                                            <li>Holiday indicators</li>
                                        </ul>
                                        
                                        <h5>Forecasting Algorithms</h5>
                                        <ul>
                                            <li><strong>ARIMA:</strong> Time series forecasting model that uses autoregressive, differencing, and moving average components to model temporal dependencies.</li>
                                            <li><strong>Linear Regression:</strong> Simple statistical model that assumes a linear relationship between input features and the target variable.</li>
                                            <li><strong>Random Forest:</strong> Ensemble of decision trees that can capture complex relationships between features and target variables.</li>
                                            <li><strong>XGBoost:</strong> Gradient boosting framework that uses sequential tree building to improve prediction accuracy.</li>
                                            <li><strong>LSTM:</strong> Long Short-Term Memory neural network, a type of recurrent neural network (RNN) that can learn long-term dependencies in time series data. Particularly effective for complex patterns and long sequences.</li>
                                        </ul>
                                        
                                        <h5>Clustering Algorithm</h5>
                                        <p><strong>K-means:</strong> Partitioning method that divides the data into k clusters, where each observation belongs to the cluster with the nearest mean. The algorithm aims to minimize the within-cluster sum of squares.</p>
                                        
                                        <h5>Evaluation Metrics</h5>
                                        <p>For forecasting models, performance is evaluated using:</p>
                                        <ul>
                                            <li><strong>Mean Absolute Error (MAE):</strong> Average of the absolute differences between predicted and actual values. Lower values indicate better performance.</li>
                                            <li><strong>Root Mean Square Error (RMSE):</strong> Square root of the average of squared differences between predicted and actual values. More sensitive to large errors than MAE.</li>
                                            <li><strong>Mean Absolute Percentage Error (MAPE):</strong> Average of the absolute percentage differences between predicted and actual values. Expressed as a percentage, making it easy to interpret.</li>
                                        </ul>
                                        
                                        <p>For clustering, evaluation is more subjective and depends on the specific use case. Common metrics include:</p>
                                        <ul>
                                            <li>Silhouette Score</li>
                                            <li>Davies-Bouldin Index</li>
                                            <li>Calinski-Harabasz Index</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="tooltip"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
    <script>
        // Particle animation for background
        class Particle {
          constructor(canvas, options = {}) {
            this.canvas = canvas
            this.ctx = canvas.getContext("2d")

            // Default options
            this.options = {
              count: options.count || 100,
              color: options.color || "#ffffff",
              radius: options.radius || { min: 1, max: 3 },
              speed: options.speed || { min: 0.1, max: 0.5 },
              opacity: options.opacity || { min: 0.1, max: 0.5 },
              connectDistance: options.connectDistance || 150,
              lineWidth: options.lineWidth || 0.5,
              lineColor: options.lineColor || "rgba(255, 255, 255, 0.2)",
            }

            this.particles = []
            this.animationFrame = null
            this.resizeTimeout = null

            this.init()
            this.bindEvents()
          }

          init() {
            this.setCanvasSize()
            this.createParticles()
            this.animate()
          }

          setCanvasSize() {
            this.canvas.width = window.innerWidth
            this.canvas.height = window.innerHeight
          }

          createParticles() {
            this.particles = []

            for (let i = 0; i < this.options.count; i++) {
              const radius = this.randomBetween(this.options.radius.min, this.options.radius.max)
              const opacity = this.randomBetween(this.options.opacity.min, this.options.opacity.max)

              this.particles.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height,
                radius: radius,
                opacity: opacity,
                color: this.options.color,
                speedX: this.randomBetween(-this.options.speed.max, this.options.speed.max),
                speedY: this.randomBetween(-this.options.speed.max, this.options.speed.max),
                lastX: 0,
                lastY: 0,
              })
            }
          }

          randomBetween(min, max) {
            return Math.random() * (max - min) + min
          }

          bindEvents() {
            window.addEventListener("resize", () => {
              clearTimeout(this.resizeTimeout)
              this.resizeTimeout = setTimeout(() => {
                this.setCanvasSize()
                this.createParticles()
              }, 200)
            })
          }

          animate() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)

            // Update and draw particles
            for (let i = 0; i < this.particles.length; i++) {
              const p = this.particles[i]

              // Save last position
              p.lastX = p.x
              p.lastY = p.y

              // Update position
              p.x += p.speedX
              p.y += p.speedY

              // Bounce off edges
              if (p.x < 0 || p.x > this.canvas.width) {
                p.speedX *= -1
              }

              if (p.y < 0 || p.y > this.canvas.height) {
                p.speedY *= -1
              }

              // Draw particle
              this.ctx.beginPath()
              this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2)
              this.ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity})`
              this.ctx.fill()

              // Connect particles
              for (let j = i + 1; j < this.particles.length; j++) {
                const p2 = this.particles[j]
                const dx = p.x - p2.x
                const dy = p.y - p2.y
                const distance = Math.sqrt(dx * dx + dy * dy)

                if (distance < this.options.connectDistance) {
                  const opacity = 1 - distance / this.options.connectDistance
                  this.ctx.beginPath()
                  this.ctx.moveTo(p.x, p.y)
                  this.ctx.lineTo(p2.x, p2.y)
                  this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.2})`
                  this.ctx.lineWidth = this.options.lineWidth
                  this.ctx.stroke()
                }
              }
            }

            this.animationFrame = requestAnimationFrame(() => this.animate())
          }

          destroy() {
            cancelAnimationFrame(this.animationFrame)
            this.particles = []
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
          }
        }

        document.addEventListener("DOMContentLoaded", () => {
          // Initialize particle background
          const canvas = document.getElementById("particles-canvas")
          if (canvas) {
            new Particle(canvas, {
              count: 100,
              radius: { min: 1, max: 3 },
              speed: { min: 0.05, max: 0.2 },
              opacity: { min: 0.1, max: 0.5 },
              connectDistance: 150,
              lineColor: "rgba(255, 255, 255, 0.1)",
            })
          }

          // Function to format numbers with commas for thousands
          function formatNumber(num) {
            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")
          }

          // Initialize date pickers with default dates (Jan 1-2, 2019)
          flatpickr("#start_date", {
            dateFormat: "Y-m-d",
            defaultDate: "2019-01-01",
            theme: "dark",
          })

          flatpickr("#end_date", {
            dateFormat: "Y-m-d",
            defaultDate: "2019-01-02",
            theme: "dark",
          })

          // Update k value display
          const kValueSlider = document.getElementById("k_value")
          const kValueDisplay = document.getElementById("k_value_display")

          if (kValueSlider && kValueDisplay) {
            kValueSlider.addEventListener("input", function () {
              kValueDisplay.textContent = this.value
            })
          }

          // Forecast form submission
          const forecastForm = document.getElementById("forecast-form")
          const forecastLoading = document.getElementById("forecast-loading")
          const forecastResult = document.getElementById("forecast-result")
          const forecastPlot = document.getElementById("forecast-plot")
          const forecastSummary = document.getElementById("forecast-summary")
          const forecastSummaryStats = document.getElementById("forecast-summary-stats")
          const pointInfo = document.getElementById("point-info")
          const pointDetails = document.getElementById("point-details")
          const metricsContainer = document.getElementById("metrics-container")
          const maeValue = document.getElementById("mae-value")
          const rmseValue = document.getElementById("rmse-value")
          const mapeValue = document.getElementById("mape-value")
          const timeSelector = document.getElementById("time-selector")

          // View options
          const viewAll = document.getElementById("view-all")
          const viewPredicted = document.getElementById("view-predicted")
          const viewActual = document.getElementById("view-actual")

          let currentForecastData = null
          let currentPlot = null

          // Function to update the plot based on view options
          function updatePlot(viewOption) {
            if (!currentForecastData) return

            const traces = []

            if (viewOption === "all" || viewOption === "predicted") {
              // Predicted values trace
              traces.push({
                x: currentForecastData.dates,
                y: currentForecastData.predictions,
                type: "scatter",
                mode: "lines+markers",
                name: "Predicted Load",
                line: {
                  color: "rgb(139, 92, 246)",
                  width: 3,
                  shape: "spline",
                },
                marker: {
                  size: 8,
                  color: "rgb(139, 92, 246)",
                  line: {
                    color: "rgb(91, 33, 182)",
                    width: 1,
                  },
                },
                hovertemplate: "<b>Date:</b> %{x}<br><b>Predicted:</b> %{y:.2f} MW<extra></extra>",
              })
            }

            if (viewOption === "all" || viewOption === "actual") {
              // Actual values trace (if available)
              if (currentForecastData.actual && currentForecastData.actual.length > 0) {
                traces.push({
                  x: currentForecastData.actual_dates,
                  y: currentForecastData.actual,
                  type: "scatter",
                  mode: "lines+markers",
                  name: "Actual Load",
                  line: {
                    color: "rgb(52, 211, 153)",
                    width: 3,
                    shape: "spline",
                  },
                  marker: {
                    size: 8,
                    color: "rgb(52, 211, 153)",
                    line: {
                      color: "rgb(5, 150, 105)",
                      width: 1,
                    },
                  },
                  hovertemplate: "<b>Date:</b> %{x}<br><b>Actual:</b> %{y:.2f} MW<extra></extra>",
                })
              }
            }

            const layout = {
              title: {
                text: "Electric Load Forecast",
                font: {
                  family: "Poppins, sans-serif",
                  size: 24,
                  color: "#f3f4f6",
                },
              },
              xaxis: {
                title: {
                  text: "Date & Time",
                  font: {
                    family: "Poppins, sans-serif",
                    size: 14,
                    color: "#9ca3af",
                  },
                },
                showgrid: true,
                gridcolor: "rgba(255,255,255,0.1)",
                gridwidth: 1,
                tickfont: {
                  family: "Poppins, sans-serif",
                  size: 12,
                  color: "#9ca3af",
                },
              },
              yaxis: {
                title: {
                  text: "Load (MW)",
                  font: {
                    family: "Poppins, sans-serif",
                    size: 14,
                    color: "#9ca3af",
                  },
                },
                showgrid: true,
                gridcolor: "rgba(255,255,255,0.1)",
                gridwidth: 1,
                tickformat: ",d", // Add comma separators for thousands
                range: [0, 25000], // Fixed y-axis range from 0 to 25,000 MW
                tickfont: {
                  family: "Poppins, sans-serif",
                  size: 12,
                  color: "#9ca3af",
                },
              },
              hovermode: "closest",
              legend: {
                x: 0,
                y: 1,
                font: {
                  family: "Poppins, sans-serif",
                  size: 12,
                  color: "#f3f4f6",
                },
              },
              margin: {
                l: 60,
                r: 30,
                b: 60,
                t: 50,
                pad: 4,
              },
              plot_bgcolor: "rgba(0,0,0,0.2)",
              paper_bgcolor: "rgba(0,0,0,0)",
              font: {
                family: "Poppins, sans-serif",
                color: "#f3f4f6",
              },
            }

            const config = {
              responsive: true,
              displayModeBar: true,
              modeBarButtonsToRemove: ["lasso2d", "select2d"],
              displaylogo: false,
            }

            Plotly.newPlot(forecastPlot, traces, layout, config)

            // Add click event to show point details
            forecastPlot.on("plotly_click", (eventData) => {
              const pointIndex = eventData.points[0].pointIndex
              const pointData = currentForecastData.detailed_data[pointIndex]

              let detailsHTML = `
                <p><strong>Date:</strong> ${pointData.formatted_date || pointData.date.split(" ")[0]}</p>
                <p><strong>Time:</strong> ${pointData.formatted_time || pointData.date.split(" ")[1]}</p>
                <p><strong>Predicted Load:</strong> ${formatNumber(pointData.prediction.toFixed(2))} MW</p>
              `

              if (pointData.actual !== undefined) {
                const error = Math.abs(pointData.actual - pointData.prediction)
                const errorPercent = ((error / pointData.actual) * 100).toFixed(2)

                detailsHTML += `
                  <p><strong>Actual Load:</strong> ${formatNumber(pointData.actual.toFixed(2))} MW</p>
                  <p><strong>Absolute Error:</strong> ${formatNumber(error.toFixed(2))} MW (${errorPercent}%)</p>
                `
              }

              pointDetails.innerHTML = detailsHTML
              pointInfo.style.display = "block"

              // Add animation
              pointInfo.classList.remove("fade-in")
              void pointInfo.offsetWidth // Trigger reflow
              pointInfo.classList.add("fade-in")
            })

            currentPlot = forecastPlot
          }

          // View option event listeners
          if (viewAll && viewPredicted && viewActual) {
            viewAll.addEventListener("click", () => {
              viewAll.classList.add("active")
              viewPredicted.classList.remove("active")
              viewActual.classList.remove("active")
              updatePlot("all")
            })

            viewPredicted.addEventListener("click", () => {
              viewAll.classList.remove("active")
              viewPredicted.classList.add("active")
              viewActual.classList.remove("active")
              updatePlot("predicted")
            })

            viewActual.addEventListener("click", () => {
              viewAll.classList.remove("active")
              viewPredicted.classList.remove("active")
              viewActual.classList.add("active")
              updatePlot("actual")
            })
          }

          // Function to filter data by day
          function filterByDay(day) {
            if (!currentForecastData) return

            // Filter detailed data for the selected day
            const filteredData = currentForecastData.detailed_data.filter((point) => {
              return point.day === day
            })

            // Create new traces for the filtered data
            const traces = []

            // Predicted values trace
            traces.push({
              x: filteredData.map((point) => point.date),
              y: filteredData.map((point) => point.prediction),
              type: "scatter",
              mode: "lines+markers",
              name: "Predicted Load",
              line: {
                color: "rgb(139, 92, 246)",
                width: 3,
                shape: "spline",
              },
              marker: {
                size: 8,
                color: "rgb(139, 92, 246)",
                line: {
                  color: "rgb(91, 33, 182)",
                  width: 1,
                },
              },
              hovertemplate: "<b>Time:</b> %{x}<br><b>Predicted:</b> %{y:.2f} MW<extra></extra>",
            })

            // Actual values trace (if available)
            const actualData = filteredData.filter((point) => point.actual !== undefined)
            if (actualData.length > 0) {
              traces.push({
                x: actualData.map((point) => point.date),
                y: actualData.map((point) => point.actual),
                type: "scatter",
                mode: "lines+markers",
                name: "Actual Load",
                line: {
                  color: "rgb(52, 211, 153)",
                  width: 3,
                  shape: "spline",
                },
                marker: {
                  size: 8,
                  color: "rgb(52, 211, 153)",
                  line: {
                    color: "rgb(5, 150, 105)",
                    width: 1,
                  },
                },
                hovertemplate: "<b>Time:</b> %{x}<br><b>Actual:</b> %{y:.2f} MW<extra></extra>",
              })
            }

            const layout = {
              title: {
                text: `Electric Load Forecast - ${filteredData[0]?.formatted_date || "Day " + day}`,
                font: {
                  family: "Poppins, sans-serif",
                  size: 24,
                  color: "#f3f4f6",
                },
              },
              xaxis: {
                title: {
                  text: "Time",
                  font: {
                    family: "Poppins, sans-serif",
                    size: 14,
                    color: "#9ca3af",
                  },
                },
                showgrid: true,
                gridcolor: "rgba(255,255,255,0.1)",
                gridwidth: 1,
                tickfont: {
                  family: "Poppins, sans-serif",
                  size: 12,
                  color: "#9ca3af",
                },
              },
              yaxis: {
                title: {
                  text: "Load (MW)",
                  font: {
                    family: "Poppins, sans-serif",
                    size: 14,
                    color: "#9ca3af",
                  },
                },
                showgrid: true,
                gridcolor: "rgba(255,255,255,0.1)",
                gridwidth: 1,
                tickformat: ",d", // Add comma separators for thousands
                range: [0, 25000], // Fixed y-axis range from 0 to 25,000 MW
                tickfont: {
                  family: "Poppins, sans-serif",
                  size: 12,
                  color: "#9ca3af",
                },
              },
              hovermode: "closest",
              legend: {
                x: 0,
                y: 1,
                font: {
                  family: "Poppins, sans-serif",
                  size: 12,
                  color: "#f3f4f6",
                },
              },
              margin: {
                l: 60,
                r: 30,
                b: 60,
                t: 50,
                pad: 4,
              },
              plot_bgcolor: "rgba(0,0,0,0.2)",
              paper_bgcolor: "rgba(0,0,0,0)",
              font: {
                family: "Poppins, sans-serif",
                color: "#f3f4f6",
              },
            }

            const config = {
              responsive: true,
              displayModeBar: true,
              modeBarButtonsToRemove: ["lasso2d", "select2d"],
              displaylogo: false,
            }

            Plotly.newPlot(forecastPlot, traces, layout, config)

            // Add click event to show point details
            forecastPlot.on("plotly_click", (eventData) => {
              const pointIndex = eventData.points[0].pointIndex
              const pointData = filteredData[pointIndex]

              let detailsHTML = `
                <p><strong>Date:</strong> ${pointData.formatted_date || pointData.date.split(" ")[0]}</p>
                <p><strong>Time:</strong> ${pointData.formatted_time || pointData.date.split(" ")[1]}</p>
                <p><strong>Predicted Load:</strong> ${formatNumber(pointData.prediction.toFixed(2))} MW</p>
              `

              if (pointData.actual !== undefined) {
                const error = Math.abs(pointData.actual - pointData.prediction)
                const errorPercent = ((error / pointData.actual) * 100).toFixed(2)

                detailsHTML += `
                  <p><strong>Actual Load:</strong> ${formatNumber(pointData.actual.toFixed(2))} MW</p>
                  <p><strong>Absolute Error:</strong> ${formatNumber(error.toFixed(2))} MW (${errorPercent}%)</p>
                `
              }

              pointDetails.innerHTML = detailsHTML
              pointInfo.style.display = "block"

              // Add animation
              pointInfo.classList.remove("fade-in")
              void pointInfo.offsetWidth // Trigger reflow
              pointInfo.classList.add("fade-in")
            })
          }

          // Function to create time selector buttons
          function createTimeSelector(data) {
            if (!data || !data.detailed_data || data.detailed_data.length === 0 || !timeSelector) return

            // Get unique days from the data
            const uniqueDays = [
              ...new Set(
                data.detailed_data.map((point) => {
                  const date = new Date(point.date)
                  return date.getDate()
                }),
              ),
            ]

            // Clear existing buttons
            timeSelector.innerHTML = ""

            // Create "All Days" button
            const allButton = document.createElement("button")
            allButton.className = "time-btn active"
            allButton.textContent = "All Days"
            allButton.addEventListener("click", function () {
              // Remove active class from all buttons
              document.querySelectorAll(".time-btn").forEach((btn) => btn.classList.remove("active"))
              // Add active class to this button
              this.classList.add("active")
              // Update plot with all data
              updatePlot(
                viewAll.classList.contains("active")
                  ? "all"
                  : viewPredicted.classList.contains("active")
                    ? "predicted"
                    : "actual",
              )
            })
            timeSelector.appendChild(allButton)

            // Create a button for each day
            uniqueDays.forEach((day) => {
              const dayData = data.detailed_data.find((point) => new Date(point.date).getDate() === day)
              const formattedDate = dayData.formatted_date || new Date(dayData.date).toLocaleDateString()

              const button = document.createElement("button")
              button.className = "time-btn"
              button.textContent = formattedDate
              button.addEventListener("click", function () {
                // Remove active class from all buttons
                document.querySelectorAll(".time-btn").forEach((btn) => btn.classList.remove("active"))
                // Add active class to this button
                this.classList.add("active")
                // Filter data by day
                filterByDay(day)
              })
              timeSelector.appendChild(button)
            })

            // Show the time selector
            timeSelector.style.display = "flex"
          }

          if (forecastForm) {
            forecastForm.addEventListener("submit", (e) => {
              e.preventDefault()

              // Show loading indicator
              if (forecastLoading) forecastLoading.style.display = "block"
              if (forecastResult) forecastResult.style.display = "none"
              if (pointInfo) pointInfo.style.display = "none"
              if (metricsContainer) metricsContainer.style.display = "none"

              // Get form data
              const formData = new FormData(forecastForm)

              // Send request to server
              fetch("/forecast", {
                method: "POST",
                body: formData,
              })
                .then((response) => response.json())
                .then((data) => {
                  if (data.error) {
                    alert(data.error)
                    if (forecastLoading) forecastLoading.style.display = "none"
                    return
                  }

                  // Store data globally
                  currentForecastData = data

                  // Update the plot
                  updatePlot("all")

                  // Create time selector if hourly data
                  if (data.forecast_interval === "hourly" || data.forecast_interval === "two_hourly") {
                    createTimeSelector(data)
                  } else if (timeSelector) {
                    timeSelector.style.display = "none"
                  }

                  // Display metrics if available
                  if (
                    data.metrics &&
                    Object.keys(data.metrics).length > 0 &&
                    maeValue &&
                    rmseValue &&
                    mapeValue &&
                    metricsContainer
                  ) {
                    // Calculate percentage metrics
                    const maePercent = ((data.metrics.mae / data.metrics.actual_mean) * 100).toFixed(2)
                    const rmsePercent = ((data.metrics.rmse / data.metrics.actual_mean) * 100).toFixed(2)

                    maeValue.textContent = `${maePercent}%`
                    rmseValue.textContent = `${rmsePercent}%`
                    mapeValue.textContent = `${data.metrics.mape.toFixed(2)}%`
                    metricsContainer.style.display = "block"

                    // Add animation
                    metricsContainer.classList.remove("fade-in")
                    void metricsContainer.offsetWidth // Trigger reflow
                    metricsContainer.classList.add("fade-in")
                  } else if (metricsContainer) {
                    metricsContainer.style.display = "none"
                  }

                  // Calculate summary statistics
                  const predictions = data.predictions
                  const avg = predictions.reduce((a, b) => a + b, 0) / predictions.length
                  const max = Math.max(...predictions)
                  const min = Math.min(...predictions)

                  // Display summary stats
                  if (forecastSummaryStats) {
                    forecastSummaryStats.innerHTML = `
                    <div class="stat-item">
                      <div class="stat-label">Average Load</div>
                      <div class="stat-value">${formatNumber(avg.toFixed(2))} MW</div>
                    </div>
                    <div class="stat-item">
                      <div class="stat-label">Maximum Load</div>
                      <div class="stat-value">${formatNumber(max.toFixed(2))} MW</div>
                    </div>
                    <div class="stat-item">
                      <div class="stat-label">Minimum Load</div>
                      <div class="stat-value">${formatNumber(min.toFixed(2))} MW</div>
                    </div>
                  `
                  }

                  // Display summary text
                  if (forecastSummary) {
                    const city = document.getElementById("city").options[document.getElementById("city").selectedIndex].text
                    const modelType =
                      document.getElementById("model_type").options[document.getElementById("model_type").selectedIndex].text
                    const startDate = document.getElementById("start_date").value
                    const endDate = document.getElementById("end_date").value

                    forecastSummary.innerHTML = `
                    This forecast shows the predicted electric load for <strong>${city}</strong> from <strong>${startDate}</strong> to <strong>${endDate}</strong> 
                    using the <strong>${modelType}</strong> model. The forecast interval is <strong>${data.forecast_interval}</strong>.
                    ${
                      data.actual && data.actual.length > 0
                        ? `Actual data is available for comparison, and performance metrics are shown above.`
                        : `No actual data is available for this period.`
                    }
                  `
                  }

                  // Show results
                  if (forecastLoading) forecastLoading.style.display = "none"
                  if (forecastResult) {
                    forecastResult.style.display = "block"

                    // Add animation
                    forecastResult.classList.remove("fade-in")
                    void forecastResult.offsetWidth // Trigger reflow
                    forecastResult.classList.add("fade-in")
                  }
                })
                .catch((error) => {
                  console.error("Error:", error)
                  alert("An error occurred while generating the forecast. Please try again.")
                  if (forecastLoading) forecastLoading.style.display = "none"
                })
            })
          }

          // Cluster form submission
          const clusterForm = document.getElementById("cluster-form")
          const clusterLoading = document.getElementById("cluster-loading")
          const clusterResult = document.getElementById("cluster-result")
          const clusterPlot = document.getElementById("cluster-plot")
          const clusterStatsContainer = document.getElementById("cluster-stats-container")

          if (clusterForm) {
            clusterForm.addEventListener("submit", (e) => {
              e.preventDefault()

              // Show loading indicator
              if (clusterLoading) clusterLoading.style.display = "block"
              if (clusterResult) clusterResult.style.display = "none"

              // Get form data
              const formData = new FormData(clusterForm)

              // Send request to server
              fetch("/cluster", {
                method: "POST",
                body: formData,
              })
                .then((response) => response.json())
                .then((data) => {
                  if (data.error) {
                    alert(data.error)
                    if (clusterLoading) clusterLoading.style.display = "none"
                    return
                  }

                  // Create interactive cluster plot with Plotly
                  const traces = []

                  // Get unique clusters
                  const uniqueClusters = [...new Set(data.clusters)]

                  // Define a color palette for clusters
                  const colorPalette = [
                    "#8b5cf6", // Purple
                    "#10b981", // Green
                    "#f59e0b", // Amber
                    "#ef4444", // Red
                    "#3b82f6", // Blue
                    "#ec4899", // Pink
                    "#14b8a6", // Teal
                    "#f97316", // Orange
                    "#6366f1", // Indigo
                    "#84cc16", // Lime
                  ]

                  // Create a trace for each cluster
                  uniqueClusters.forEach((cluster, index) => {
                    const indices = data.clusters.map((c, i) => (c === cluster ? i : -1)).filter((i) => i !== -1)

                    const clusterX = indices.map((i) => data.pca_x[i])
                    const clusterY = indices.map((i) => data.pca_y[i])

                    // Create hover text with feature values
                    const hoverTexts = indices.map((i) => {
                      let text = `<b>Cluster:</b> ${cluster}<br>`
                      for (const feature in data.feature_values) {
                        text += `<b>${feature}:</b> ${data.feature_values[feature][i].toFixed(2)}<br>`
                      }
                      return text
                    })

                    traces.push({
                      x: clusterX,
                      y: clusterY,
                      mode: "markers",
                      type: "scatter",
                      name: `Cluster ${cluster}`,
                      marker: {
                        size: 12,
                        color: colorPalette[index % colorPalette.length],
                        line: {
                          color: "rgba(0, 0, 0, 0.3)",
                          width: 1,
                        },
                        opacity: 0.8,
                      },
                      text: hoverTexts,
                      hoverinfo: "text",
                    })
                  })

                  const layout = {
                    title: {
                      text: `K-Means Clustering (k=${uniqueClusters.length})`,
                      font: {
                        family: "Poppins, sans-serif",
                        size: 24,
                        color: "#f3f4f6",
                      },
                    },
                    xaxis: {
                      title: {
                        text: "PCA Component 1",
                        font: {
                          family: "Poppins, sans-serif",
                          size: 14,
                          color: "#9ca3af",
                        },
                      },
                      showgrid: true,
                      zeroline: true,
                      zerolinecolor: "rgba(255,255,255,0.2)",
                      gridcolor: "rgba(255,255,255,0.1)",
                      gridwidth: 1,
                      tickfont: {
                        family: "Poppins, sans-serif",
                        size: 12,
                        color: "#9ca3af",
                      },
                    },
                    yaxis: {
                      title: {
                        text: "PCA Component 2",
                        font: {
                          family: "Poppins, sans-serif",
                          size: 14,
                          color: "#9ca3af",
                        },
                      },
                      showgrid: true,
                      zeroline: true,
                      zerolinecolor: "rgba(255,255,255,0.2)",
                      gridcolor: "rgba(255,255,255,0.1)",
                      gridwidth: 1,
                      tickfont: {
                        family: "Poppins, sans-serif",
                        size: 12,
                        color: "#9ca3af",
                      },
                    },
                    hovermode: "closest",
                    legend: {
                      x: 0,
                      y: 1,
                      font: {
                        family: "Poppins, sans-serif",
                        size: 12,
                        color: "#f3f4f6",
                      },
                    },
                    margin: {
                      l: 60,
                      r: 30,
                      b: 60,
                      t: 50,
                      pad: 4,
                    },
                    plot_bgcolor: "rgba(0,0,0,0.2)",
                    paper_bgcolor: "rgba(0,0,0,0)",
                    font: {
                      family: "Poppins, sans-serif",
                      color: "#f3f4f6",
                    },
                  }

                  const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ["lasso2d", "select2d"],
                    displaylogo: false,
                  }

                  if (clusterPlot) {
                    Plotly.newPlot(clusterPlot, traces, layout, config)
                  }

                  // Display cluster statistics
                  if (clusterStatsContainer) {
                    clusterStatsContainer.innerHTML = ""

                    // Create a table for cluster statistics
                    const table = document.createElement("table")
                    table.className = "table table-striped table-hover"

                    // Create table header
                    const thead = document.createElement("thead")
                    thead.innerHTML = `
                    <tr>
                      <th>Cluster</th>
                      <th>Size</th>
                      <th>Avg. Temp (°F)</th>
                      <th>Avg. Humidity (%)</th>
                      <th>Avg. Wind Speed (mph)</th>
                      <th>Weekend (%)</th>
                    </tr>
                  `
                    table.appendChild(thead)

                    // Create table body
                    const tbody = document.createElement("tbody")
                    data.cluster_stats.forEach((stat, index) => {
                      const row = document.createElement("tr")
                      row.innerHTML = `
                      <td>
                        <span style="display: inline-block; width: 12px; height: 12px; background-color: ${colorPalette[index % colorPalette.length]}; border-radius: 50%; margin-right: 8px;"></span>
                        ${stat.cluster_id}
                      </td>
                      <td>${stat.size}</td>
                      <td>${stat.avg_temp.toFixed(1)}</td>
                      <td>${stat.avg_humidity.toFixed(1)}</td>
                      <td>${stat.avg_wind_speed.toFixed(1)}</td>
                      <td>${stat.weekend_pct.toFixed(1)}</td>
                    `
                      tbody.appendChild(row)
                    })
                    table.appendChild(tbody)

                    clusterStatsContainer.appendChild(table)
                  }

                  // Show results
                  if (clusterLoading) clusterLoading.style.display = "none"
                  if (clusterResult) {
                    clusterResult.style.display = "block"

                    // Add animation
                    clusterResult.classList.remove("fade-in")
                    void clusterResult.offsetWidth // Trigger reflow
                    clusterResult.classList.add("fade-in")
                  }
                })
                .catch((error) => {
                  console.error("Error:", error)
                  alert("An error occurred while generating the clusters. Please try again.")
                  if (clusterLoading) clusterLoading.style.display = "none"
                })
            })
          }

          // Add animation to cards
          document.querySelectorAll(".card").forEach((card, index) => {
            card.style.animationDelay = `${index * 0.1}s`
            card.classList.add("fade-in")
          })

          // Add glow effect to buttons
          document.querySelectorAll(".btn-primary").forEach((btn) => {
            btn.classList.add("btn-glow")
          })
        })
    </script>
</body>
</html>
